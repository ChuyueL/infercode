>=
enum_variant_list
*=
/=
line_comment
bracketed_type
union_item
]
return
crate
:
token_tree
^=
tuple_struct_pattern
meta
%
use
>
if_expression
trait
unit_expression
meta_arguments
use_wildcard
async
block
field_initializer
function_signature_item
&
meta_item
generic_function
const
integer_literal
_type
constrained_type_parameter
continue
field_initializer_list
::
async_block
)
@
scoped_type_identifier
impl
stmt
dynamic_type
type_arguments
vis
qualified_type
parameters
super
struct_item
break
move
higher_ranked_trait_bound
reference_expression
boolean_literal
?
function_modifiers
+
block_comment
reference_pattern
type_identifier
try_expression
tuple_pattern
closure_expression
field_identifier
ty
pub
trait_item
self_parameter
_
float_literal
primitive_type
_pattern
mutable_specifier
attribute_item
while_expression
.
match_arm
scoped_use_list
mod_item
call_expression
type_item
const_parameter
range_pattern
=
_declaration_statement
if
scoped_identifier
inner_attribute_item
for
function_type
/
token_tree_pattern
..
match_pattern
false
array_expression
variadic_parameter
#
metavariable
%=
self
pointer_type
negative_literal
while_let_expression
for_expression
use_list
;
macro_rule
generic_type_with_turbofish
continue_expression
foreign_mod_item
<<=
await
struct_pattern
field_expression
^
struct
>>
}
array_type
const_item
|
source_file
remaining_field_pattern
as
enum_variant
true
enum
macro_rules!
arguments
<
<<
associated_type
field_declaration_list
_expression
generic_type
<=
literal
,
declaration_list
||
function_item
else
empty_statement
type_binding
visibility_modifier
identifier
token_repetition
macro_definition
parenthesized_expression
default
ref_pattern
reference_type
let_declaration
match_block
shorthand_field_initializer
removed_trait_bound
loop_expression
!=
range_expression
or_pattern
use_declaration
"
*
break_expression
else_clause
-=
where
path
=>
+=
index_expression
let
union
where_clause
!
slice_pattern
match
loop
raw_string_literal
unsafe
|=
bounded_type
tuple_expression
binary_expression
empty_type
static
mut_pattern
if_let_expression
unary_expression
closure_parameters
impl_item
static_item
mod
use_as_clause
dyn
field_pattern
string_literal
[
in
lifetime
unsafe_block
struct_expression
abstract_type
macro_invocation
_literal
assignment_expression
match_expression
_literal_pattern
>>=
(
ref
==
expr
enum_item
{
token_repetition_pattern
fragment_specifier
captured_pattern
tuple_type
while
loop_label
type_parameters
parameter
field_declaration
...
trait_bounds
&&
->
$
-
item
char_literal
..=
pat
extern_modifier
await_expression
return_expression
for_lifetimes
type_cast_expression
optional_type_parameter
base_field_initializer
ordered_field_declaration_list
ident
shorthand_field_identifier
unit_type
extern
tt
compound_assignment_expr
&=
escape_sequence
token_binding_pattern
where_predicate
type
extern_crate_declaration
'
fn
