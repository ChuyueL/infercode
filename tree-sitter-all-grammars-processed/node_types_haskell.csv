data_family
type_unboxed_sum
type_instance
in
cpp
infixr
pat_infix
type_role
type_star
quasiquote
label
inst_tyinst
type_operator
data_instance
|]
'
do_module
comment
exp_sum_empty
exp_case
exp_do
fundeps
pat_typed
exp_in
stmt
module
gdpat
data_constructor
quantifiers
quasiquote_body
default_declaration
type_tuple
constructor_operator
exp_apply
pat_strict
exp_infix
<-
nominal
do
pattern
;
ccall
mdo
type_family
bind_pattern
fundep
{
exp_let
all_names
qualified_type
con_tuple
exp_tuple
newtype_constructor
.
via
rec
gadt_constructor
foreign
guard_equation
deriving
class_head
exp_unboxed_sum
->
hiding
foreign_export
type_list
exp_let_in
integer
pat_fields
type_unboxed_tuple
data_constructor_record
exp_negation
pat_literal
ticked
\
if
stdcall
pat_irrefutable
jvm
class
[
pat_as
operator
class_body
variable
instance
-
instance_head
]
exp_if_guard
exp_th_quoted_name
exp_list
type_alias
context
strict_type
safety
default_signature
exp_field
exp_section_left
char
calling_convention
data
unsafe
stock
export
newtype
pat_view
type_apply
anyclass
type_literal
fixity
of
`
expent
impent
class_name
pat_parens
con_list
pragma
|
alts
top_splice
infixl
=>
phantom
}
=
decl_type
representational
dotnet
type_name
exp_record
import_list
)
''
_
exp_list_comprehension
::
safe
guards
@
exp_name
namespace
qualified_constructor_operator
type_infix
where
export_names
decls
alt
qualified_type_operator
quoter
implicit_parid
qualified
as
field
case
foreign_import
pat_negation
pat_record
exp_unboxed_tuple
decl_tyfam_sig
exp_arithmetic_sequence
function
import_con_names
guard
string
cplusplus
default
implicit_param
type_parens
pat_tuple
qualified_constructor
pat_wildcard
pattern_synonym
qualified_variable
forall
patterns
import_item
constructor
equation
tycon_arrow
pat_list
capi
exp_lambda
else
exp_cond
fun
pat_unboxed_tuple
wildcard
role
varop
float
exp_literal
con_unit
~
constructors
deriving_declaration
inst_datainst
(
exp_type_application
type_variable
exports
promoted
let
pat_apply
annotated_type_variable
record_fields
pattern_guard
qualified_operator
prim
import
pat_name
exp_parens
deriving_strategy
interruptible
role_annotation
head
splice
then
data_constructor_infix
..
constraint
type
(# 
empty_file
adt
qual
qualified_module
âˆ€
haskell
exp_lambda_case
exp_section_right
signature
pat_field
import_package
comma
infix
family
