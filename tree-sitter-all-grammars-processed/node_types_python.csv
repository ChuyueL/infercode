with_item
if_clause
interpolation
-
list_splat_pattern
break
format_specifier
for_in_clause
boolean_operator
finally_clause
|=
wildcard_import
string
decorator
tuple_pattern
function_definition
finally
pass_statement
assert
.
or
exec_statement
else_clause
list_pattern
+=
default_parameter
future_import_statement
aliased_import
list_comprehension
keyword_argument
concatenated_string
import_from_statement
nonlocal
comment
pattern_list
generator_expression
pass
}
assignment
>>=
!=
lambda
//
<<
assert_statement
{
is
continue
try
conditional_expression
comparison_operator
|
primary_expression
import
return_statement
<>
parameter
:
del
print
**=
parenthesized_expression
expression
->
<=
not
import_prefix
parameters
exec
type_conversion
for_statement
global_statement
except_clause
block
in
<
binary_operator
dictionary_splat
integer
raise
decorated_definition
pattern
*
@
~
class_definition
named_expression
tuple
elif
:=
//=
_compound_statement
augmented_assignment
except
=
float
continue_statement
while
(
^
@=
%=
with
def
expression_list
list
parenthesized_list_splat
/
%
__future__
while_statement
lambda_parameters
relative_import
"
ellipsis
none
list_splat
if
call
module
dictionary_comprehension
with_statement
set
for
+
nonlocal_statement
dictionary
[
-=
print_statement
raise_statement
not_operator
false
class
expression_statement
await
escape_sequence
*=
typed_default_parameter
yield
**
chevron
and
elif_clause
<<=
identifier
,
attribute
)
>>
else
true
]
async
break_statement
try_statement
>=
subscript
from
if_statement
==
/=
^=
typed_parameter
argument_list
global
return
unary_operator
slice
&
&=
delete_statement
pair
import_statement
format_expression
_simple_statement
as
dictionary_splat_pattern
set_comprehension
>
dotted_name
type
