>=
/=
double_dot
value_expr
line_comment
colon
function_declaration_left
>
infix_declaration
union_variant
upper_case_identifier
glsl_end
string_constant_expr
bin_op_expr
list_expr
::
value_qid
exposed_type
type_declaration
alias
+
block_comment
effect
tuple_pattern
module
close_char
lower_type_name
list_pattern
import
operator_as_function_expr
infix
as_clause
arrow
//
type_alias_declaration
type_expression
eq
port_annotation
field_access_expr
dot
string_escape
if
exposed_union_constructors
/
anything_pattern
case_of_expr
open_quote
operator
right_parenthesis
record_expr
cons_pattern
record_type
lower_pattern
glsl_content
pattern
function_call_expr
<|
record_pattern
pipe
field_type
lower_case_identifier
^
upper_case_qid
>>
regular_string_part
as
parenthesized_expr
glsl_code_expr
<
<<
<=
open_char
port
left_parenthesis
char_constant_expr
||
else
if_else_expr
number_literal
case_of_branch
</>
left_square_bracket
import_clause
record_base_identifier
glsl_begin
negate_expr
close_quote
*
where
<?>
type_variable
operator_identifier
let
left_brace
right_square_bracket
exposing
right_brace
|=
then
exposing_list
backslash
anonymous_function_expr
type_annotation
|.
in
unit_expr
case
file
==
comma
tuple_type
exposed_operator
tuple_expr
underscore
&&
field_accessor_function_expr
|>
exposed_value
-
field
module_declaration
type_ref
of
invalid_string_escape
++
value_declaration
nullary_constructor_argument_pattern
number_constant_expr
let_in_expr
union_pattern
type
