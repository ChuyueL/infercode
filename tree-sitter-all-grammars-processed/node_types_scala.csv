assignment_expression
finally
type_identifier
parameters
package_clause
class_parameter
comment
return_expression
*
floating_point_literal
context_bound
match
arguments
case_clause
finally_clause
stable_type_identifier
extends_clause
interpolation
projected_type
;
try
{
case_block
identifier
compound_type
package_object
.
#
match_expression
import_declaration
block
capture_pattern
,
integer_literal
renamed_identifier
extends
final
if
tuple_type
new
override
class
_pattern
[
<%
unit
]
-
null_literal
generic_type
parenthesized_expression
_definition
field_expression
protected
infix_expression
alternative_pattern
function_declaration
view_bound
template_body
type_arguments
type_definition
upper_bound
$
character_literal
operator_identifier
sealed
return
|
}
with
=>
false
=
var_definition
var_declaration
)
instance_expression
call_expression
modifiers
+
compilation_unit
@
lazy
true
parameter
val
class_definition
tuple_expression
lower_bound
private
catch_clause
interpolated_string
function_type
def
case
typed_pattern
parameter_types
contravariant_type_parameter
<:
guard
string
infix_type
if_expression
_expression
try_expression
throw
val_definition
else
package_identifier
:
wildcard
package
type_parameters
~
annotation
object_definition
repeated_parameter_type
(
interpolated_string_expression
boolean_literal
case_class_pattern
lazy_parameter_type
import_selectors
class_parameters
abstract
import
trait_definition
stable_identifier
prefix_expression
infix_pattern
var
trait
symbol_literal
tuple_pattern
object
generic_function
throw_expression
type
implicit
covariant_type_parameter
catch
>:
function_definition
!
val_declaration
