val_declaration
extends
parameter_types
lazy_parameter_type
trait
interpolation
-
catch_clause
instance_expression
match_expression
object_definition
implicit
;
<:
finally_clause
boolean_literal
stable_type_identifier
type_identifier
val
string
tuple_pattern
finally
function_definition
.
if_expression
package_clause
protected
comment
infix_type
return_expression
floating_point_literal
generic_function
{
try
!
trait_definition
|
try_expression
import
new
upper_bound
parameter
package_object
throw
:
tuple_type
parenthesized_expression
>:
$
object
lower_bound
_pattern
parameters
block
alternative_pattern
type_arguments
capture_pattern
import_selectors
var_declaration
match
symbol_literal
call_expression
prefix_expression
extends_clause
import_declaration
lazy
assignment_expression
*
@
~
abstract
class_definition
stable_identifier
final
override
_definition
infix_expression
var_definition
generic_type
case_block
=
(
modifiers
null_literal
with
def
package
character_literal
field_expression
projected_type
case
val_definition
typed_pattern
type_parameters
throw_expression
if
guard
=>
repeated_parameter_type
#
+
interpolated_string_expression
covariant_type_parameter
<%
private
[
compound_type
operator_identifier
false
class
_expression
view_bound
case_class_pattern
interpolated_string
tuple_expression
renamed_identifier
infix_pattern
annotation
identifier
,
class_parameter
)
else
package_identifier
contravariant_type_parameter
context_bound
true
]
function_type
sealed
type_definition
integer_literal
compilation_unit
arguments
unit
template_body
wildcard
return
catch
class_parameters
var
function_declaration
}
case_clause
type
