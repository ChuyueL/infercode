>=
defer_statement
go
*=
/=
]
short_var_declaration
return
assignment_statement
_simple_type
channel_type
:
^=
type_alias
&^=
%
>
element
&^
block
<-
&
receive_statement
fallthrough
const
break_statement
_type
goto_statement
continue
package_identifier
)
_statement
slice_expression
import_spec_list
qualified_type
nil
go_statement
type_declaration
break
var_spec
range
+
method_spec_list
type_identifier
for_statement
parameter_declaration
keyed_element
field_identifier
defer
type_switch_statement
interface
var
package_clause
import
:=
float_literal
goto
package
import_declaration
.
function_declaration
select
select_statement
func
dot
literal_value
switch
call_expression
=
map
if
for
function_type
/
type_assertion_expression
false
%=
pointer_type
inc_statement
map_type
label_name
;
<<=
^
struct
}
>>
func_literal
array_type
|
source_file
chan
true
interpreted_string_literal
communication_case
continue_statement
<
composite_literal
<<
field_declaration_list
<=
_expression
const_declaration
for_clause
,
argument_list
||
int_literal
return_statement
expression_case
else
type_case
empty_statement
fallthrough_statement
range_clause
parameter_list
type_spec
identifier
parenthesized_expression
send_statement
default
imaginary_literal
!=
"
*
-=
expression_list
slice_type
const_spec
+=
index_expression
--
rune_literal
default_case
!
raw_string_literal
|=
blank_identifier
method_spec
binary_expression
unary_expression
_simple_statement
[
dec_statement
comment
import_spec
labeled_statement
>>=
(
case
==
{
selector_expression
implicit_length_array_type
field_declaration
...
interface_type
&&
type_conversion_expression
-
if_statement
variadic_parameter_declaration
variadic_argument
var_declaration
struct_type
++
method_declaration
expression_switch_statement
&=
escape_sequence
parenthesized_type
type
