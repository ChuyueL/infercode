composite_literal
type_switch_statement
chan
type_assertion_expression
-
break
func
fallthrough_statement
fallthrough
dec_statement
send_statement
;
field_declaration_list
var_spec
struct
|=
method_spec
label_name
_statement
type_declaration
type_identifier
dot
blank_identifier
--
<-
field_declaration
.
_simple_type
||
default_case
+=
&^
slice_expression
package_clause
empty_statement
keyed_element
float_literal
comment
binary_expression
>>=
!=
import_spec_list
<<
literal_value
{
continue
!
|
range_clause
import
return_statement
parameter_declaration
:
int_literal
parenthesized_expression
selector_expression
go_statement
<=
struct_type
type_spec
slice_type
for_statement
type_conversion_expression
block
import_spec
<
&^=
var_declaration
call_expression
default
import_declaration
*
field_identifier
:=
go
method_spec_list
variadic_argument
communication_case
inc_statement
map_type
=
const_declaration
continue_statement
&&
interface_type
(
^
%=
package
expression_list
variadic_parameter_declaration
/
%
defer_statement
func_literal
pointer_type
implicit_length_array_type
channel_type
receive_statement
case
"
if
select_statement
rune_literal
for
+
defer
unary_expression
qualified_type
[
const
for_clause
assignment_statement
-=
interpreted_string_literal
false
_expression
_type
escape_sequence
*=
map
imaginary_literal
goto
<<=
identifier
goto_statement
,
const_spec
)
>>
else
package_identifier
method_declaration
interface
type_alias
true
]
array_type
expression_case
function_type
break_statement
raw_string_literal
>=
...
if_statement
==
/=
^=
switch
argument_list
parenthesized_type
source_file
parameter_list
type_case
return
select
&
&=
_simple_statement
expression_switch_statement
element
labeled_statement
short_var_declaration
++
index_expression
range
var
function_declaration
}
nil
>
type
