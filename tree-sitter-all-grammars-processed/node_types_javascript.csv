augmented_assignment_expression
extends
arrow_function
_destructuring_pattern
-
break
catch_clause
===
method_definition
;
finally_clause
|=
_statement
variable_declarator
_declaration
switch_body
string
decorator
finally
super
--
switch_statement
.
||
variable_declaration
??=
else_clause
static
+=
undefined
empty_statement
class_heritage
comment
binary_expression
}
nested_identifier
>>=
!=
<<
{
let
sequence_expression
try
continue
debugger
!
delete
jsx_text
array
of
assignment_pattern
|
import
new
yield_expression
export_clause
return_statement
throw
:
**=
parenthesized_expression
class_declaration
property_identifier
object
export_specifier
generator_function_declaration
<=
class_body
regex
for_statement
hash_bang_line
in
computed_property_name
<
import_clause
throw_statement
await_expression
get
call_expression
default
jsx_namespace_name
rest_parameter
&&=
target
assignment_expression
!==
*
ternary_expression
@
~
for_in_statement
?.
this
do_statement
namespace_import
statement_block
meta_property
regex_flags
template_substitution
=
while
continue_statement
&&
(
^
switch_default
function
||=
%=
with
array_pattern
/
%
>>>
export_statement
while_statement
program
case
template_string
jsx_expression
"
update_expression
if
`
=>
lexical_declaration
with_statement
new_expression
for
set
+
jsx_opening_element
unary_expression
>>>=
[
const
-=
false
class
_expression
expression_statement
await
jsx_fragment
*=
escape_sequence
typeof
yield
**
spread_element
formal_parameters
<<=
identifier
??
,
debugger_statement
statement_identifier
)
>>
else
switch_case
${
true
object_pattern
]
async
instanceof
break_statement
try_statement
>=
...
from
if_statement
?
==
do
/=
shorthand_property_identifier
^=
switch
regex_pattern
arguments
jsx_self_closing_element
void
jsx_attribute
named_imports
generator_function
jsx_element
return
export
&
&=
member_expression
pair
subscript_expression
'
import_statement
catch
number
as
null
labeled_statement
++
import_specifier
var
function_declaration
jsx_closing_element
>
public_field_definition
